/****************************************************************************/
/*																			*/
/*       CopyrIght (c)  1993 - 1996 Accelerated Technology, Inc.            */
/*																			*/
/* PROPRIETARY RIGHTS of Accelerated Technology are involved in 			*/
/* the subject matter of this material.  All manufacturing, reproduction,	*/
/* use, and sales rights pertaining to this subject matter are governed 	*/
/* by the license agreement.  The recipient of this software inplicitly 	*/
/* accepts the terms of the license.										*/
/*																			*/
/****************************************************************************/
/****************************************************************************/
/* FILE NAME										VERSION 				*/
/*																			*/
/*      TCP_ERRS.C                                    4.0                   */
/*																			*/
/* COMPONENT																*/
/*	All the routines in this file are used for the TCP/IP, Nucleus			*/
/*	interface.	They will handle all the processing, storing, and query 	*/
/*	for any error codes generated by the TCP/IP modules.					*/
/*																			*/
/* DESCRIPTION																*/
/*																			*/
/* This file will hold all the Nukelus routines for handling the of the TCP */
/* errors.	These routines are supplied by us for handling internal errors	*/
/* generated by the TCP/IP code.											*/
/*																			*/
/* AUTHOR																	*/
/*																			*/
/* Craig L. Meredith														*/
/*																			*/
/* DATA STRUCTURES															*/
/*																			*/
/*	struct TCP_IP_ERR	: Holds the error information.						*/
/*	struct TCP_MSG_STR	: Holds the error number and a pointer to the str.	*/
/*																			*/
/* FUNCTIONS																*/
/*	void NU_Tcp_Log_Error (uint16 err_num, uint8 stat						*/
/*						   uint8 *file, uint16 line);						*/
/*	void NU_Tcp_Clear_All_Errors ();										*/
/*	unit8 *NU_Tcp_Error_String (uint16 error_number);						*/
/*																			*/
/* DEPENDENCIES 															*/
/*																			*/
/* None.																	*/
/*																			*/
/* HISTORY																	*/
/*																			*/
/*	   NAME 			DATE		REMARKS 								*/
/*																			*/
/* Maiqi Qian      12/06/96           Fixed the time wrap around (spr0229)  */
/*                                                                          */
/****************************************************************************/
#ifdef PLUS
#include "nucleus.h"
#else
#include "nu_defs.h"    /* added during ATI mods - 10/20/92, bgh */
#include "nu_extr.h"
#endif
#include "tcp.h"
#include "tcp_errs.h"
#include "tcpdefs.h"
#include "externs.h"

/* Setup and init the TCP_Avail_Index value at compile time */
int16 TCP_Avail_Index = -1;

/* Allocate the space for the error array */
struct TCP_IP_ERR NU_Tcp_Err_List [MAX_TCP_ERRORS];

/****************************************************************************/
/* FUNCTION 																*/
/*	NU_Tcp_Log_Error () 													*/
/*                                                                          */
/* DESCRIPTION                                                              */
/*	This routine will handle storing the current error number into the		*/
/*	error structure.  The current port number, task id, socket number,		*/
/*	and current system time into the structure.  This routine will handle	*/
/*	searching for the next available location, set the next location to 	*/
/*	avail, and then set its own location to TRUE for being used.  The data	*/
/*	will then be stored into the structure. 								*/
/*																			*/
/* AUTHOR                                                                   */
/*                                                                          */
/* Craig L. Meredith                                                        */
/*                                                                          */
/* CALLED BY																*/
/*                                                                          */
/*      many functions                                                      */
/*                                                                          */
/* CALLS																	*/
/*                                                                          */
/*   n_clicks()                                                             */
/*   NU_Current_Task_Pointer()                                              */
/*	 NU_Current_Task_ID ()													*/
/*                                                                          */
/* INPUTS																	*/
/*	uint16 err_num	:	Error number to store.								*/
/*	uint8  stat 	:	Status flag to store for error severity.			*/
/*	uint8  *file	:	Pointer to the current filename in which the error	*/
/*						happened.											*/
/*	uint16 line 	:	Line number in the file where the error happened.	*/
/*                                                                          */
/* OUTPUTS																	*/
/*	Load passed in and calculated information into the NU_Tcp_Err_List		*/
/*	array, and also will update the value of the TCP_Avail_Index.			*/
/*                                                                          */
/* HISTORY                                                                  */
/*                                                                          */
/*     NAME             DATE        REMARKS                                 */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

void NU_Tcp_Log_Error (uint16 err_num, uint8 stat, int8 *file, uint16 line)
{

    int16 i;
	struct TCP_IP_ERR *err_list_ptr;

#ifdef PRINT_ERROR_MSG
    printf("ERROR - number: %d  status: %d  file: %s  line: %d\n\r", err_num,
                        stat, file, line);
#endif

    /* check for this is the first time an error has been called */
	if (TCP_Avail_Index == -1)
	{
		/* start at the first location */
		TCP_Avail_Index = 0;
	}

	/* load the needed information into the current array location */
	err_list_ptr = &NU_Tcp_Err_List [TCP_Avail_Index];

	/* get the current port id number and store it */
	err_list_ptr->tie_port_num = 0;

	/* get the currently running task id */
#ifdef PLUS
    err_list_ptr->tie_task_id = NU_Current_Task_Pointer ();
#else
    err_list_ptr->tie_task_id = NU_Current_Task_ID ();
#endif

	/* get the current socket number */
	err_list_ptr->tie_sock_num = 0;

	/* store the passed in error number */
	err_list_ptr->tie_err_num = err_num;

	/* store the passed in status for this error */
	err_list_ptr->tie_err_stat = stat;

	/* store the current system time */
    err_list_ptr->tie_err_time = n_clicks();

	/* store the passed in filename where the error occurred */
    for (i = 0; ((i < MAX_TCP_FILENAME) && (file != (int8 *)NU_NULL)); i++)
	{
        err_list_ptr->tie_file [i] = (uint8)*file++;
	}

	/* store the passed in line number where the error occured */
	err_list_ptr->tie_line_num = line;

	/* increment the global index forward and handle the wrap */
	TCP_Avail_Index = (TCP_Avail_Index + 1) % MAX_TCP_ERRORS;

}  /* end NU_Tcp_Log_Error */

/****************************************************************************/
/* FUNCTION 																*/
/*	NU_Tcp_Clear_All_Errors ()												*/
/*                                                                          */
/* DESCRIPTION                                                              */
/*	This routine will reset the NU_Tcp_Err_Index value back to -1, which	*/
/*  will in effect, clear all the current errors from the NU_Tcp_Err_List   */
/*  array.                                                                  */
/*																			*/
/* AUTHOR                                                                   */
/*                                                                          */
/* Craig L. Meredith                                                        */
/*                                                                          */
/* CALLED BY																*/
/*                                                                          */
/*                                                                          */
/* CALLS																	*/
/*   NU_Request_Resource ()                                                 */
/*   NU_Release_Resource ()                                                 */
/*	 NU_Obtain_Semaphore () 												*/
/*	 NU_Release_Semaphore () 												*/
/*                                                                          */
/* INPUTS																	*/
/*	None.																	*/
/*                                                                          */
/* OUTPUTS																	*/
/*	Will update the value to the TCP_Avail_Index variable.					*/
/*                                                                          */
/* HISTORY                                                                  */
/*                                                                          */
/*     NAME             DATE        REMARKS                                 */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

VOID NU_Tcp_Clear_All_Errors (VOID)
{
#ifdef PLUS
    STATUS status;
#else
    int16 status;                        /* status of memory allocation */
#endif

	/* allocate the TCP/IP resource for blocking during this time */
#ifdef PLUS
    status = NU_Obtain_Semaphore(&TCP_Resource, NU_SUSPEND);
#else
    status = NU_Request_Resource(TCP_Resource, NU_WAIT_FOREVER);
#endif
    if (status != NU_SUCCESS)
    {
		return;
	}

	/* clear all the error by reseting the index value */
	TCP_Avail_Index = -1;

	/* deallocate the TCP/IP resource */
#ifdef PLUS
    status = NU_Release_Semaphore(&TCP_Resource);
#else
    status = NU_Release_Resource(TCP_Resource);
#endif
	if (status != NU_SUCCESS)
	{
		return;
	}
}  /* end NU_Tcp_Clear_All_Errors */

#ifdef TCP_ERR_STRS
	/*
	 * This structure array is only used and defined if the def TCP_ERR_STRS is
	 * defined.  This will allow for space saving if you do not wish to handle the
	 * printing of the static text strings explaining the actual error code.
	 */
    struct TCP_MSG_STR TCP_Error_Strings[] =
	{
		{0, "Error unknown"},
		{100, "Network jammed, probable break in wire"},
		{101, "Could not initialize hardware level network driver"},
		{102, "ERROR: The conflicting machine is using the same IP number"},
		{103, "RARP request failed, an IP number is required"},
		{300, "Bad IP checksum"},
		{301, "IP packet not for me"},
		{302, "IP packet with options received"},
		{303, "IP: unknown higher layer protocol"},
		{304, "IP: fragmented packet received, frags not supported"},
		{400, "TCP: bad checksum"},
		{401, "ACK invalid for TCP syn sent"},
		{403, "TCP in unknown state"},
		{404, "Invalid port for TCPsend"},
		{405, "TCP connection reset by other host"},
		{406, "Null port specified for ackandtrans"},
		{407, "Packet received for invalid port -- reset sent"},
		{500, "No internal TCP ports available"},
		{501, "Warning: Event queue filled, probably non-fatal"},
		{504, "Local host or gateway not responding"},
		{505, "Memory allocation error, cannot open port"},
		{506, "Not allowed to connect to broadcast address"},
		{507, "Reset received: syn sent, host is refusing connection"},
        {508, "Partition allocation error"},
        {600, "ICMP:   Echo reply"},
		{603, "ICMP:   Destination unreachable"},
		{604, "ICMP:   Source Quench"},
		{605, "ICMP:   Redirect, another gateway is more efficient"},
		{608, "ICMP:   Echo requested (ping requested)"},
		{611, "ICMP:   Time Exceeded on Packet"},
		{612, "ICMP:   Parameter problem in IP"},
		{613, "ICMP:   Timestamp request"},
		{614, "ICMP:   Timestamp reply"},
		{615, "ICMP:   Information request"},
		{616, "ICMP:   Information reply"},
		{699, "ICMP: Checksum error"},
		{700, "Bad UDP checksum"},
		{800, "Domain: Name request to server failed"},
		{801, "Domain: Using default domain"},
		{802, "Domain: name does not exist"},
		{803, "Domain: UDP name server did not resolve the name"},
		{804, "Domain: name server failed, unknown reason"},
		{805, "Host machine not in configuration file"},
		{806, "Missing IP number, requires domain lookup"},
		{900, "Session: Cannot find or open configuration file"},
		{901, "Session: Cannot allocate memory for processing"},
		{902, "Session: Invalid keyword in configuration file"},
		{903, "Session: Element too long (>200), maybe missing quote"},
        {904, "Session: Probable missing quote marks, a field must be on one line"},
		{905, "Session: 'name' field required before other machine entries"},
		{906, "Session: Syntax error, invalid IP number"},
		{907, "Session: Syntax error, Subnet mask invalid"},
		{908, "Session: Syntax error, IP address for this PC is invalid"},
		{-1, ""}
	};

/****************************************************************************/
/* FUNCTION                                                                 */
/*  NU_Tcp_Error_String ()                                                  */
/*                                                                          */
/* DESCRIPTION                                                              */
/*  This routine will handle returning the actual character string for the  */
/*  error number passed in.  This will not change the current error array   */
/*  in any way.                                                             */
/*                                                                          */
/* AUTHOR                                                                   */
/*                                                                          */
/* Craig L. Meredith                                                        */
/*                                                                          */
/* CALLED BY                                                                */
/*                                                                          */
/*                                                                          */
/* CALLS                                                                    */
/*                                                                          */
/*   NU_Request_Resource ()                                                 */
/*   NU_Release_Resource ()                                                 */
/*	 NU_Obtain_Semaphore () 												*/
/*	 NU_Release_Semaphore () 												*/
/*                                                                          */
/* INPUTS                                                                   */
/*  uint16 error_number :   Error number for which a string is wished.      */
/*                                                                          */
/* OUTPUTS                                                                  */
/*  uint8 * returned to the caller, which will point to the character str.  */
/*                                                                          */
/* HISTORY                                                                  */
/*                                                                          */
/*     NAME             DATE        REMARKS                                 */
/*                                                                          */
/*                                                                          */
/****************************************************************************/
uint8 *NU_Tcp_Error_String (uint16 error_number)
{
    struct TCP_MSG_STR *string_ptr;
#ifdef PLUS
    STATUS status;
#else
    int16 status;                        /* status of memory allocation */
#endif

		/* allocate the TCP/IP resource for blocking during this time */
#ifdef PLUS
        status = NU_Obtain_Semaphore(&TCP_Resource, NU_SUSPEND);
#else
        status = NU_Request_Resource(TCP_Resource, NU_WAIT_FOREVER);
#endif
    if (status != NU_SUCCESS)
        return ((uint8 *) NU_NULL);

    /* start at the front of the list */
    string_ptr = &TCP_Error_Strings[0];

    /*
     * search thourgh the array until the error number is found or end
     * of the list.  If the end of the list is reached, a NU_NULL will be
     * returned.
     */
    while (string_ptr->tms_err_str != (uint8 *)NU_NULL)
    {
        /* check for this is the error string we want */
        if (string_ptr->tms_err_num == error_number)
        {
            return ((uint8 *)string_ptr);
        }  /* end error string found */

        /* move to the next possible error string */
        string_ptr++;
    }

    /* deallocate the TCP/IP resource */
#ifdef PLUS
    status = NU_Release_Semaphore(&TCP_Resource);
#else
    status = NU_Release_Resource(TCP_Resource);
#endif
    if (status != NU_SUCCESS)
        return ((uint8 *) NU_NULL);
        
    /* return NU_NULL, error string not found */
    return ((uint8 *) NU_NULL);
}  /* end NU_Tcp_Error_String */
#endif	/* TCP_ERR_STRS */
